const applyDotenv = require("../../../../lambdas/applyDotenv");
const dotenv = require("dotenv");
const AWS = require("aws-sdk");
const {ConnectMongo} = require("../../ConnectMongo");
const {verify} = require("jsonwebtoken");
const axios = require("axios");
const db = require("../../../DataBase");
const moment = require("moment-timezone");
const jwt = require("jsonwebtoken");
const serviceAPI = require("../../api/api");
const AWSAPI = require("../../../router/AWS");

const {
    AWS_SECRET, AWS_ACCESS, AWS_REGION, AWS_BUCKET_NAME, MONGO_URI, ADMIN_DB_NAME,
    AWS_TOKEN, SUNIL_MONGO_URI, AWS_LAMBDA_SIGNUP,GROUP_MONGO_URI,GROUP_DB_NAME
} = applyDotenv(dotenv)

AWS.config.update({
    accessKeyId: AWS_SECRET,
    secretAccessKey: AWS_ACCESS,
    region: AWS_REGION
});

const AwsLogin = db.AWSLogin

const dynamoDB = new AWS.DynamoDB.DocumentClient();



// 1. ÌöåÏõêÍ∞ÄÏûÖ ( Í∑∏Î£π ÏûêÎèôÏÉùÏÑ± Î∞è lambdaÏóêÏÑú response Î∞õÏùÄÍ±∏Î°ú user_key Î∞îÎ°ú Ï†ÄÏû• ) - renewalSignUp
// 2. ÌöåÏõê ÌÉàÌá¥ ( Í∑∏Î£π ÎÇ¥ Í∑∏Î£πÏõêÎì§ fcm Î≥¥ÎÇ¥Í≥† Î≥∏Ïù∏+Í∑∏Î£πÏõê Ìè¨Ìï® ÎîîÎ∞îÏù¥Ïä§ ÌÖåÏù¥Î∏î ÏÇ≠Ï†ú, Í∑∏Ïô∏ ÌÖåÏù¥Î∏îÎì§ÏùÄ Î≥∏Ïù∏ tables Í≥ÑÏ†ï ÏÇ≠Ï†ú + s3,Î†àÏΩîÎìú,history ÏÇ≠Ï†ú) - renewalSignOut
// 3. ÎßàÏä§ÌÑ∞ ÎîîÎ∞îÏù¥Ïä§ÏïÑÏù¥Îîî Ï∂îÍ∞Ä ( Í∑∏Î£π ÎÇ¥ Î≥∏Ïù∏ unitÏóê Ï†ÄÏû• )- renewalSaveDeviceId
// 4. Ïú†Ï†ÄÌÇ§ ÎèôÍ∏∞Ìôî ( ÏóÖÎç∞Ïù¥Ìä∏ Ìï† Ïú†Ï†ÄÌÇ§Í∞Ä ÏûàÏùÑÍ≤ΩÏö∞ Í∑∏Î£π ÎîîÎπÑÍπåÏßÄ ÏóÖÎç∞Ïù¥Ìä∏ ) - renewalSaveUserKey
// 5. ÎîîÎ∞îÏù¥Ïä§ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏ ( ÎßàÏä§ÌÑ∞Ïùò Îã§Ïù¥ÎÇòÎ™®ÎîîÎπÑ ÎîîÎ∞îÏù¥Ïä§ ÌÖåÏù¥Î∏îÏùò device_nameÍ≥º Í∑∏Î£πÏùò Î≥∏Ïù∏ unit ÎÇ¥ device_info ÎÇ¥  device_name ÎèôÍ∏∞Ìôî ) -renewalUpdateDeviceInfo
// 6. ÎßàÏä§ÌÑ∞ ÎîîÎ∞îÏù¥Ïä§ ÏïÑÏù¥Îîî ÏÇ≠Ï†ú ( Ìï¥Îãπ ÎîîÎ∞îÏù¥Ïä§ ÏïÑÏù¥ÎîîÏùò Í∂åÌïú Ï∞æÏùÄ ÌõÑ Í∑∏Î£πÏõê Ìè¨Ìï® ÎîîÎ∞îÏù¥Ïä§ÌÖåÏù¥Î∏î ÏàúÌöåÌïòÎ©∞ ÏÇ≠Ï†ú + fcmÎèÑ Î≥¥ÎÉÑ , Î≥∏Ïù∏ tablesÏóêÏÑú device_id ÏÇ≠Ï†ú ÌïÑÌÑ∞Î°ú
// s3, Î†àÏΩîÎìú, historyÎäî ÎîîÎ∞îÏù¥Ïä§ÏïÑÏù¥ÎîîÎ°ú ÌïÑÏöîÍ∞íÎì§ ÎèåÍ±∞ÎÇò Îã§Ïù¥Î†âÌä∏ ÏÇ≠Ï†ú ) -renewalDeleteDeviceId

const renewals = function () {
    return{
        async renewalSignUp(req, res) {
            let {company, ...data} = req.body;
            const saveTime = moment().tz('Asia/Seoul');
            console.log(data);

            // üîê ÌïÑÏàòÍ∞í Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
            if (!company || typeof company !== 'string' || company.trim() === '') {
                return res.status(400).send("Invalid value for 'company'.");
            }

            // ‚úÖ Ï≤´ Í∏ÄÏûê ÎåÄÎ¨∏Ïûê + ÎÇòÎ®∏ÏßÄ ÏÜåÎ¨∏ÏûêÎ°ú Ï†ïÍ∑úÌôî
            company = company.charAt(0).toUpperCase() + company.slice(1).toLowerCase();

            if (!data.user_id || typeof data.user_id !== 'string' || data.user_id.trim() === '') {
                return res.status(400).send("'user_id' is a required field.");
            }

            if (!data.user_pw || typeof data.user_pw !== 'string' || data.user_pw.trim() === '') {
                return res.status(400).send("'user_pw' is a required field.");
            }

            if (!data.user_email || typeof data.user_email !== 'string' || data.user_email.trim() === '') {
                return res.status(400).send("'user_email' is a required field.");
            }

            if (!data.name || typeof data.name !== 'string' || data.name.trim() === '') {
                return res.status(400).send("'name' is a required field.");
            }

            if (!data.tel || typeof data.tel !== 'string' || data.tel.trim() === '') {
                return res.status(400).send("'tel' is a required field.");
            }


            try {
                const {collection: tableCol} = await ConnectMongo(MONGO_URI, ADMIN_DB_NAME, 'tables');
                const {collection: membersCol} = await ConnectMongo(GROUP_MONGO_URI, GROUP_DB_NAME, 'groups');
                const allData = await tableCol.find({company}).toArray();
                const maxContractNumObj = allData
                    .filter(item => item.contract_num && item.contract_num.startsWith(`${company}-`))
                    .reduce((max, item) => {
                        const num = parseInt(item.contract_num.split(`${company}-`)[1], 10);
                        return (num > parseInt(max.contract_num.split(`${company}-`)[1], 10)) ? item : max;
                    }, {contract_num: `${company}-0`});

                const maxContractNum = maxContractNumObj ? parseInt(maxContractNumObj.contract_num.split(`${company}-`)[1], 10) : 0;

                const findData = await tableCol.find({
                    $or: [
                        { id: data.user_id },
                        { email: data.user_email }
                    ]
                }).toArray();

                if (findData.length !== 0) {
                    let dupMsg = '';
                    if (findData.some(u => u.id === data.user_id)) dupMsg += 'UserId ';
                    if (findData.some(u => u.email === data.user_email)) dupMsg += 'Email ';
                    return res.status(400).send(`Duplicate ${dupMsg.trim()}`);
                }

                const key = data.user_id;
                // const tel = "00000000000";
                const addr = `${company}-address`;

                const saveAwsData = {
                    user_id: key,
                    user_pw: data.user_pw,
                    name: data.name,
                    tel: data.tel,
                    addr: addr,
                    company,
                };

                try {
                    const awsResponse = await axios.post(AWS_LAMBDA_SIGNUP, saveAwsData);
                    console.log('success SignUp');
                    const awsResponseData = awsResponse.data;
                    let lambdaDecoded = jwt.verify(awsResponseData.token, AWS_TOKEN); // ÎòêÎäî AWS Ï™ΩÏóêÏÑú ÏÇ¨Ïö©ÌïòÎäî ÌÇ§
                    let newUserKey = lambdaDecoded.user_key; // Ïó¨Í∏∞Ïóê Ïú†Ï†ÄÌÇ§Í∞Ä Îì§Ïñ¥ÏûàÏùå

                    const mongoSignUpData = {
                        name: data.name,
                        tel: data.tel,
                        addr: addr,
                        email: data.user_email,
                        contract_num: `${company}-${Number(maxContractNum) + 1}`,
                        device_id: null,
                        company,
                        contract_service: 'Ï£ºÍ≥ÑÏïΩÏûê',
                        id: data.user_id,
                        communication: 'O',
                        service_name: `${company}Service`,
                        service_start: saveTime.format('YYYY-MM-DD'),
                        service_end: "9999-12-30",
                        start_up: 'O',
                        user_key: newUserKey
                    };

                    const memberData = {
                        group_name: `${data.name}Ïùò Í∑∏Î£π`,
                        company,
                        user_key:newUserKey,
                        unit:[
                            {
                                user_key:newUserKey,
                                user_name:data.name,
                                alias_name:null,
                                email:data.user_email,
                                latest_device_id:"",
                                device_info:[],
                                token:null,
                                auth:true,
                                state:"ACTIVE",
                                join_at:moment().tz('Asia/Seoul').toDate(),
                            }
                        ],
                        created_at:moment().tz('Asia/Seoul').toDate()
                    }


                    const insertSignUpResult = await tableCol.insertOne(mongoSignUpData);
                    const insertMembersResult = await membersCol.insertOne(memberData);

                    console.log(insertSignUpResult);
                    console.log(insertMembersResult)

                    const signUpData = await tableCol.findOne({id: data.user_id});
                    const groupData = await membersCol.findOne({user_key:newUserKey})

                    return res.status(200).json({
                        msg: 'Success Signup',
                        signUpData,
                        groupData,
                        awsResponse: awsResponseData
                    });
                } catch (awsErr) {
                    console.log(awsErr);
                    return res.status(502).send(awsErr);
                }


            } catch (err) {
                console.error(err);
                return res.status(500).send(err);
            }

        },


        async renewalSignOut(req, res) {
            const token = req.headers['token'];
            if (!token) return res.status(400).send('Token is required.');

            let user_key;
            try {
                ({ user_key } = jwt.verify(token, process.env.AWS_TOKEN));
            } catch (e) {
                return res.status(401).send("Unauthorized: Invalid token.");
            }

            // MongoDB Ïó∞Í≤∞
            const { collection: tablesCol } = await ConnectMongo(MONGO_URI, ADMIN_DB_NAME, 'tables');
            const { collection: membersCol } = await ConnectMongo(GROUP_MONGO_URI, GROUP_DB_NAME, 'groups');
            const findData = await tablesCol.findOne({ user_key });
            if (!findData) return res.status(404).send("User data not found.");

            const s3 = new AWS.S3();
            const DEVICE_TABLE = 'DEVICE_TABLE';
            const RECORD_TABLE = "RECORD_TABLE";
            const USER_TABLE = 'USER_TABLE';
            const BUCKET_NAME = 'doorbell-video';

            // 1. Í∑∏Î£π Ï†ïÎ≥¥ Ï°∞Ìöå (ÎßàÏä§ÌÑ∞ Î≥∏Ïù∏ Í∑∏Î£π)
            const group = await membersCol.findOne({ user_key });
            if (!group) return res.status(404).send("Group not found.");


            // Î≥∏Ïù∏ USER_TABLE row ÏÇ≠Ï†ú
            await dynamoDB.delete({
                TableName: USER_TABLE,
                Key: { user_key }
            }).promise();

            // 4. Î™®Îì† Í∑∏Î£πÏõê(unit)Îì§Ïùò device_infoÏóêÏÑú device_id, user_key Ï°∞Ìï©ÏúºÎ°ú DEVICE_TABLE ÏÇ≠Ï†ú
            for (const unit of (group.unit || [])) {
                if (Array.isArray(unit.device_info)) {
                    for (const device of unit.device_info) {
                        if (device.device_id) {
                            await dynamoDB.delete({
                                TableName: DEVICE_TABLE,
                                Key: {
                                    device_id: device.device_id,
                                    user_key: unit.user_key
                                }
                            }).promise();
                        }
                    }
                }
            }

            // 5. Í∑∏Î£π(MongoDB members)Í≥º Î≥∏Ïù∏ ÌÖåÏù¥Î∏î row(MongoDB tables) ÏÇ≠Ï†ú
            await membersCol.deleteOne({ user_key });
            await tablesCol.deleteOne({ user_key });

            // 6. Í∑∏Î£π ÎÇ¥ Î™®Îì† unit.device_infoÏùò device_id Í∏∞Ï§ÄÏúºÎ°ú Record, S3, History Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
            //    (device_id Ï§ëÎ≥µ Ï†úÍ±∞Ìï¥ÏÑú uniqueÌïòÍ≤å ÌïúÎ≤àÏî©Îßå ÏÇ≠Ï†ú)
            const masterDeviceIds = findData.device_id
                ? findData.device_id.split(",").map(d => d.trim())
                : [];

            for (const device_id of masterDeviceIds) {
                // RECORD_TABLE: Ìï¥Îãπ device_idÏóê Ìï¥ÎãπÌïòÎäî Î™®Îì† Î†àÏΩîÎìú ÏÇ≠Ï†ú
                const scanResult = await dynamoDB.scan({
                    TableName: RECORD_TABLE,
                    FilterExpression: 'device_id = :device_id',
                    ExpressionAttributeValues: { ':device_id': device_id }
                }).promise();

                if (scanResult.Items.length > 0) {
                    for (const record of scanResult.Items) {
                        await dynamoDB.delete({
                            TableName: RECORD_TABLE,
                            Key: {
                                device_id: record.device_id,
                                file_location: record.file_location // Ï†ïÎ†¨ÌÇ§
                            }
                        }).promise();
                    }
                }

                // S3: device_idÎ°ú Î≥ÄÌôòÌïú prefixÎ°ú S3 Í∞ùÏ≤¥ Ï†ÑÏ≤¥ ÏÇ≠Ï†ú
                const s3ObjectPrefix = device_id.replace(/:/g, '_') + '/';
                const listedObjects = await s3.listObjectsV2({ Bucket: BUCKET_NAME, Prefix: s3ObjectPrefix }).promise();
                if (listedObjects.Contents.length > 0) {
                    await s3.deleteObjects({
                        Bucket: BUCKET_NAME,
                        Delete: { Objects: listedObjects.Contents.map(object => ({ Key: object.Key })) }
                    }).promise();
                }

                // History (MongoDB): device_idÎ°ú Ï†ÑÏ≤¥ ÏÇ≠Ï†ú
                await History.deleteMany({ device_id });
            }

            // 7. ÌöåÏÇ¨Í∞Ä SunilÏù∏ Í≤ΩÏö∞ Sunil-Doorbell Ïª¨Î†âÏÖòÏóêÏÑú Ï∂îÍ∞Ä ÏÇ≠Ï†ú
            if (findData.company === 'Sunil') {
                const { collection: sunilCol } = await ConnectMongo(SUNIL_MONGO_URI, 'Sunil-Doorbell', 'users');
                await sunilCol.deleteMany({ id: findData.id });
            }

            // 8. ÏôÑÎ£å ÏùëÎãµ (ÏòÅÎ¨∏)
            return res.status(200).send("Account deletion and group removal completed successfully.");
        },


        async renewalSaveDeviceId(req, res) {
            let { user_key, device_id, device_name, op } = req.body;

            try {
                const { collection: tablesCol } = await ConnectMongo(MONGO_URI, ADMIN_DB_NAME, 'tables');
                const { collection: membersCol } = await ConnectMongo(GROUP_MONGO_URI, GROUP_DB_NAME, 'groups');
                const findData = await tablesCol.findOne({ user_key });

                if (!findData) {
                    return res.status(404).send('User not found');
                }

                device_id = device_id.toLowerCase();

                const raw = (findData.device_id ?? "").trim();   // null/undefined ÎåÄÎπÑ
                const lower = raw ? raw.toLowerCase().split(",").filter(Boolean) : [];
                if (!lower.includes(device_id)) {
                    const newValue = raw ? `${raw},${device_id}` : device_id;
                    await tablesCol.updateOne({ user_key }, { $set: { device_id: newValue } });
                }

                if (op === "update") {
                    // device_nameÎßå ÏàòÏ†ï (Í∞íÏù¥ ÏôîÏùÑ ÎïåÎßå)
                    if (req.body.device_name !== undefined) {
                        await membersCol.updateOne(
                            {
                                user_key,
                                "unit.user_key": user_key,
                                "unit.auth": true,
                                "unit.device_info.device_id": device_id
                            },
                            {
                                $set: {
                                    "unit.$[u].device_info.$[d].device_name": device_name,
                                    "unit.$[u].latest_device_id": device_id
                                }
                            },
                            {
                                arrayFilters: [
                                    { "u.user_key": user_key, "u.auth": true },
                                    { "d.device_id": device_id }
                                ]
                            }
                        );
                    }
                } else { // create or ÎØ∏ÏßÄÏ†ï
                    // Ïù¥ÎØ∏ ÏûàÎäîÏßÄ ÌôïÏù∏ ÌõÑ ÏóÜÏúºÎ©¥ prepend
                    const groupDoc = await membersCol.findOne(
                        { user_key, "unit.user_key": user_key, "unit.auth": true },
                        { projection: { unit: { $elemMatch: { user_key, auth: true } } } }
                    );
                    if (!groupDoc?.unit?.length) return res.status(404).send("group/unit ÏóÜÏùå");

                    const devArr = groupDoc.unit[0].device_info || [];
                    const exist = devArr.find(d => (d.device_id || "").toLowerCase() === device_id);

                    if (!exist) {
                        await membersCol.updateOne(
                            { user_key, "unit.user_key": user_key, "unit.auth": true },
                            {
                                $push: {
                                    "unit.$.device_info": {
                                        $each: [{ device_id, device_name, privacy: false }],
                                        $position: 0
                                    }
                                }
                            }
                        );
                    } else {
                        // Ïù¥ÎØ∏ ÏûàÏóàÏúºÎ©¥ Ïù¥Î¶ÑÎßå ÏóÖÎç∞Ïù¥Ìä∏
                        await membersCol.updateOne(
                            {
                                user_key,
                                "unit.user_key": user_key,
                                "unit.auth": true,
                                "unit.device_info.device_id": device_id
                            },
                            {
                                $set: {
                                    "unit.$[u].device_info.$[d].device_name": device_name
                                }
                            },
                            {
                                arrayFilters: [
                                    { "u.user_key": user_key, "u.auth": true },
                                    { "d.device_id": device_id }
                                ]
                            }
                        );
                    }
                }
                // const groups = await membersCol.findOne({ user_key });
                // const targetUnit = (groups.unit || []).find(u => u.user_key === user_key);
                // await membersCol.updateOne(
                //     { user_key, "unit.user_key": user_key },
                //     { $set: { "unit.$.device_info": [
                //                 {
                //                     device_id,
                //                     device_name:"noname",
                //                     privacy: false
                //                 },
                //                 ...((targetUnit && targetUnit.device_info) || [])
                //             ] } }
                // );

                return res.status(200).send('success')

            } catch (err) {
                console.error('Error in saveDeivceId:', err);
                return res.status(500).send('Internal Server Error');
            }
        },



        async renewalDeleteDeviceId(req, res) {
            const data  = req.body;
            const token = req.headers['token'];

            if (!data.device_id) return res.status(400).json({ error: 'There is no device_id inside the body.' });
            if (!token)         return res.status(400).send('Token not found.');

            const lowerDeviceId = String(data.device_id).toLowerCase();

            let verify;
            try {
                verify = jwt.verify(token, process.env.AWS_TOKEN);
            } catch (e) {
                return res.status(401).json({ error: 'Token invalid.' });
            }

            // === Ïª¨Î†âÏÖò / ÏÉÅÏàò ===
            const { collection: tablesCol  } = await ConnectMongo(MONGO_URI,       ADMIN_DB_NAME, 'tables');
            const { collection: membersCol } = await ConnectMongo(MONGO_URI,       ADMIN_DB_NAME, 'members');
            const DEVICE_TABLE = 'DEVICE_TABLE';
            const RECORD_TABLE = 'RECORD_TABLE';
            const BUCKET_NAME  = 'doorbell-video';
            const s3           = new AWS.S3();

            // 1. Í∑∏Î£π(ÎßàÏä§ÌÑ∞) Ï°∞Ìöå
            const group = await membersCol.findOne({ user_key: verify.user_key });
            if (!group) return res.status(404).json({ error: "Group (master) not found." });

            // 2. (Í∑∏Î£πÏõêÏùÄ Í±¥ÎìúÎ¶¨ÏßÄ ÏïäÏùå) ÎßàÏä§ÌÑ∞ unitÎßå device_infoÏóêÏÑú Ìï¥Îãπ device_id Ï†úÍ±∞
            await membersCol.updateOne(
                { user_key: verify.user_key, "unit.user_key": verify.user_key, "unit.auth": true },
                { $pull: { "unit.$.device_info": { device_id: lowerDeviceId } } }
            );

            // 3. tables.device_id Î¨∏ÏûêÏó¥ÏóêÏÑú Ìï¥Îãπ id Ï†úÍ±∞ (ÎßàÏä§ÌÑ∞Îßå)
            const findUser = await tablesCol.findOne({ user_key: verify.user_key });
            if (findUser) {
                let updated = (findUser.device_id || '')
                    .split(',')
                    .map(v => v.trim())
                    .filter(v => v && v.toLowerCase() !== lowerDeviceId)
                    .join(',');
                if (!updated) updated = null;
                await tablesCol.updateOne({ _id: findUser._id }, { $set: { device_id: updated } });
            }

            // 4. History ÏÇ≠Ï†ú
            await History.deleteMany({ device_id: lowerDeviceId });

            // 5. DynamoDB ÏÇ≠Ï†ú (ÎßàÏä§ÌÑ∞Îßå)
            await dynamoDB.delete({
                TableName: DEVICE_TABLE,
                Key: { device_id: lowerDeviceId, user_key: verify.user_key }
            }).promise();

            // 6. RECORD_TABLE ÏÇ≠Ï†ú (device_id Í∏∞Ï§Ä)
            const scan = await dynamoDB.scan({
                TableName: RECORD_TABLE,
                FilterExpression: 'device_id = :id',
                ExpressionAttributeValues: { ':id': lowerDeviceId }
            }).promise();

            if (scan.Items?.length) {
                for (const r of scan.Items) {
                    await dynamoDB.delete({
                        TableName: RECORD_TABLE,
                        Key: { device_id: r.device_id, file_location: r.file_location }
                    }).promise();
                }
            }

            // 7. S3 ÏÇ≠Ï†ú
            const prefix = lowerDeviceId.replace(/:/g, '_') + '/';
            let ct;
            do {
                const listed = await s3.listObjectsV2({
                    Bucket: BUCKET_NAME,
                    Prefix: prefix,
                    ContinuationToken: ct
                }).promise();

                if (listed.Contents?.length) {
                    await s3.deleteObjects({
                        Bucket: BUCKET_NAME,
                        Delete: { Objects: listed.Contents.map(o => ({ Key: o.Key })) }
                    }).promise();
                }
                ct = listed.IsTruncated ? listed.NextContinuationToken : null;
            } while (ct);

            // 8. Í∏∞Ï°¥ Î¶¨ÌÑ¥ ÌòïÏãù Ïú†ÏßÄ
            const lastData = await tablesCol.findOne({ user_key: verify.user_key });

            return res.status(200).json({
                msg: `Deleted (MongoDB, DynamoDB, S3 Video-Data) device_id: ${lastData.id}-${lastData.name}`,
                changeData: lastData
            });
        },


    }

}

module.exports = renewals;
